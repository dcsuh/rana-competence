---
title: "sem"
output: html_document
date: "2022-12-06"
---

```{r, message = F}
library(here)

library(tidyverse)
library(magrittr)
library(piecewiseSEM)
library(nlme)
library(lmerTest)
library(mgcv)
library(dagitty)
```

Read in data
```{r, message = F}
comm_data <- readRDS(here("processed_data","comm_data.rds"))
```


The purpose of this script was to try out SEM with the ranavirus data to answer whether there were direct or indirect effects of temperature on infection prevalence that were possible being mediated by abundance or community competence. SEM can help us to understand relationships between multiple variables that may be causally related to each other. 


Make lagged data - I'll use this later to compare results using lagged and not lagged data
```{r}
prev_cc <- comm_data

order <- prev_cc[order(prev_cc$WetAltID, prev_cc$Month.1),]

#this removes months out of sequence
order <- order[-c(4,14,47,90),]

order %<>% add_column(lag_cc = NA, lag_size = NA, lag_temp = NA)


#create new column that includes previous month's value for cc
for(n in 2:nrow(order)){
  order$lag_cc[n] <- order$cc[n-1]
  order$lag_size[n] <- order$size[n-1]
  order$lag_temp[n] <- order$MeanWaterTempPredC[n-1]
}

#remove the first entry for each wetland to remove the carryover from the last wetland
clean <- order %>% group_by(WetAltID) %>% filter(duplicated(WetAltID) | n()==1)

```


This is just a way to visualize the SEM. I think it must have a method for customizing the orientation of things to make it look nicer but I haven't tried to figure out how to do that.

```{r}
prev_mod <- dagitty("dag{
  temp -> cc
  temp -> size
  temp -> prev
  cc -> prev
  size -> prev
             }")

plot(graphLayout(prev_mod))

```


Just some histograms to check the distributions of the data

```{r}
comm_data %>% ggplot(.,aes(x=MeanWaterTempPredC)) + geom_histogram()
comm_data %>% ggplot(.,aes(x=size)) + geom_histogram()
comm_data %>% ggplot(.,aes(x=log10(size))) + geom_histogram()
comm_data %>% ggplot(.,aes(x=cc)) + geom_histogram()
comm_data %>% ggplot(.,aes(x=log(cc))) + geom_histogram()
comm_data %>% ggplot(.,aes(x=Prevalence)) + geom_histogram()
comm_data %>% ggplot(.,aes(x=log10(Prevalence+1))) + geom_histogram()

```


And some basic plots for all the univariate relationships I am considering

```{r}
comm_data %>% ggplot(.,aes(x=MeanWaterTempPredC, y = cc)) + geom_point() + geom_smooth() + 
  labs(title = "cc ~ temp")
comm_data %>% ggplot(.,aes(x=MeanWaterTempPredC, y = log10(size))) + geom_point() + geom_smooth() + 
  labs(title = "log(size) ~ temp")
comm_data %>% ggplot(.,aes(x=MeanWaterTempPredC, y = Prevalence)) + geom_point() + geom_smooth() + 
  labs(title = "Prev ~ temp")
comm_data %>% ggplot(.,aes(x=log10(cc), y = Prevalence)) + geom_point() + geom_smooth(method = "lm") + 
  labs(title = "Prev ~ log(cc)")
comm_data %>% ggplot(.,aes(x=log10(size), y = Prevalence)) + geom_point() + geom_smooth(method = "lm") + 
  labs(title = "Prev ~ log(size)")
```



How to model nonlinear effect of temperature?
- hump-shaped relationship may be expected with temperature



# SEMs

In this first iteration, I first propose the relationships independently and then combine them later to generate the SEM. Each relationship is modeled as a linear regression and is evaluated separately. The 'piecewiseSEM' package generates a test statistic (Fisher's C) and and AIC score through a method known as "tests of directed seperation". This method evalutes the relationships between variables that are *un*specified in the model and asks whether these relationships are truly independent or whether some causal relationship may exist. piecewiseSEM relies on a priori knowledge of the system that can be used to rationalize expected relationships in the data. The benefits of piecewiseSEM is that it allows for non-independence of the data and allows for each relationship to be evaluated independently using 

cc ~ mean water temp; 
size ~ mean water temp; 
prevalence ~ cc + size + mean water temp

```{r}
cc_temp <- lm(log10(cc) ~ (MeanWaterTempPredC), data = comm_data)
size_temp <- lm(log10(size) ~ (MeanWaterTempPredC), data = comm_data)
prev_cc <- lm(Prevalence ~ log10(cc) + log10(size), data = comm_data)
prev_temp_cc <- glm(Prevalence ~ log10(cc) + log10(size) + MeanWaterTempPredC, data = comm_data)

sem <- psem(cc_temp, size_temp, prev_cc)
sem_1 <- psem(cc_temp, size_temp, prev_temp_cc)
```

```{r}
comm_data %<>% filter(MeanWaterTempPredC>0)

cc_temp <- gam(log10(cc) ~ s(MeanWaterTempPredC), data = comm_data)
size_temp <- lm(log10(size) ~ (MeanWaterTempPredC), data = comm_data)
prev_cc <- lm(Prevalence ~ log10(cc) + log10(size), data = comm_data)
prev_temp_cc <- glm(Prevalence ~ log10(cc) + log10(size) + MeanWaterTempPredC, data = comm_data)


summary(cc_temp)

#fix error
#sem <- psem(cc_temp, size_temp, prev_cc)
#sem_1 <- psem(cc_temp, size_temp, prev_temp_cc)
```

Using lagged data
```{r}
lagged_cc_temp <- lm(lag_cc ~ lag_temp, data = clean)
lagged_size_temp <- lm(log10(lag_size) ~ lag_temp + lag_cc, data = clean)
lagged_prev_cc <- lm(Prevalence ~ lag_cc + log10(lag_size), data = clean)
lagged_prev_temp_cc <- lm(Prevalence ~ lag_cc + log10(lag_size) + lag_temp, data = clean)

sem_lagged <- psem(lagged_cc_temp, lagged_size_temp, lagged_prev_cc)
sem_1_lagged <- psem(lagged_cc_temp, lagged_size_temp, lagged_prev_temp_cc)
```


```{r}
basisSet(sem)
dSep(sem, conditioning = T)
fisherC(sem)
coefs(sem, intercepts = T)
rsquared(sem)
```

```{r}
basisSet(sem_1)
dSep(sem_1, conditioning = T)
fisherC(sem_1)
coefs(sem_1, intercepts = T)
rsquared(sem_1)
```


```{r}
summary(sem)
plot(sem)
plot(sem, return = T)
```

```{r}
summary(sem_1)
plot(sem_1)
plot(sem_1, return = T)
```


```{r}
summary(sem_lagged)
plot(sem_lagged)
plot(sem_lagged, return = T)
```

```{r}
summary(sem_1_lagged)
plot(sem_1_lagged)
plot(sem_1_lagged, return = T)
```


Lefcheck example
This is example data and code that I got from Lefcheck's tutorial
https://cran.r-project.org/web/packages/piecewiseSEM/vignettes/piecewiseSEM.html#worked-example 

```{r}
data(shipley)
```

```{r}
dd_lat <-  lme(DD~lat, random = ~1|site/tree, na.action = na.omit, 
    data = shipley)

date_dd <-lme(Date~DD, random = ~1|site/tree, na.action = na.omit, 
    data = shipley)

growth_date <-  lme(Growth~Date, random = ~1|site/tree, na.action = na.omit, 
    data = shipley)

live_growth <-  glmer(Live~Growth+(1|site)+(1|tree), 
    family=binomial(link = "logit"), data = shipley)
```

```{r}
shipley_sem <- psem(dd_lat, date_dd, growth_date, live_growth)
```

```{r}
summary(shipley_sem)
```



Covariance-based SEM

Traditional SEM creates a single variance-covariance matrix between all variables and relationships between variables are estimated simultaneously from that matrix. This method assumes independence and normality of errors which are probably not things we can assume about our dataset. I also haven't yet figured out how to implement this method of SEM.

```{r}

```

