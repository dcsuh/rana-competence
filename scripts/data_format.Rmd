---
title: "Data Formatting"
author: "Daniel Suh"
date: "2/19/2021"
output: html_document
---

This Rmd is used for all of the data formatting that is required for use by the scripts that create figures. Scripts for figures should only include minimal code that manipulates the data. 


Packages
```{r}
library(tidyverse)
library(magrittr)
library(vegan)

library(here)
```



Data
```{r}
here()
data <- read_csv(here("/data/weighted_prev_competence_111220.csv"))
names <- read_csv(here("/data/species_names_ids.csv"))
```

viral loads
```{r}
vl <- data %>% dplyr::select(vl.4:vl.42) %>% distinct() %>% pivot_longer(vl.4:vl.42)
vl$species_code <- as.double(gsub("vl.","",vl$name))
vl %<>% full_join(., names, by="species_code")
vl %<>% mutate(., ln_value = log(value)) %>% mutate(., log10_value = log10(value))
```
`r nrow(vl)` total species; `sum(vl$value>0)`species with non-zero viral loads

Transmission Model for two species - primarily used by fig1
```{r}
#define function contour(): inputs are parameters and output is values for grid search for R0
contour <- function(trans_1_min, trans_1_max, trans_3_min, trans_3_max, mort1, mort2, degr) {
  #expand data
  data <- expand_grid("trans1" = seq(from = trans_1_min, to = trans_1_max, by = 0.00001),
                      "trans2" = c(0.0001),
                      "trans3" = seq(from = trans_3_min, to = trans_3_max, by = 0.00001),
                      "shed1" = c(rep(1/2, length("trans1"))),
                      "shed2" = c(rep(1/2, length("trans1"))),
                      "reco1" = c(rep(1/10, length("trans1"))),
                      "reco2" = c(rep(1/10, length("trans1"))),
                      "mort1" = c(mort1), 
                      "mort2" = c(mort2), 
                      "degr" = c(degr), 
                      "birth1" = c(rep(5/3, length("trans1"))),
                      "birth2" = c(rep(5/3, length("trans1"))))
  
  #calculate disease-free equilibria for use in next-gen matrix
  data %<>% add_column(dfe1 = (data$birth1/data$mort1),dfe2 = (data$birth2/data$mort2)) 
  #make matrix
  mat <- matrix(1, nrow = 3, ncol = 3)
  
  
  m <- nrow(data)
  #calculate eigenvalue using next-gen matrix. max eigenvalue is R0
  for(n in 1:m){
    mat[1] = (data$trans1[n]*data$dfe1[n])/(data$reco1[n]+data$mort1[n])
    mat[2] = (data$trans1[n]*data$dfe2[n])/(data$reco2[n]+data$mort2[n])
    mat[3] = (data$shed1[n]/data$degr[n])
    mat[4] = (data$trans2[n]*data$dfe1[n])/(data$reco1[n]+data$mort1[n])
    mat[5] = (data$trans2[n]*data$dfe2[n])/(data$reco2[n]+data$mort2[n])
    mat[6] = (data$shed2[n]/data$degr[n])
    mat[7] = (data$trans3[n]*data$dfe1[n])/(data$reco1[n]+data$mort1[n])
    mat[8] = (data$trans3[n]*data$dfe2[n])/(data$reco2[n]+data$mort2[n])
    mat[9] = 0
    eigen <- max(eigen(mat)$values)
    data$eigen[n] <- eigen
  }
  
  data$span1 <- 1/data$mort1 #lifespan for species 1
  data$span2 <- 1/data$mort2 #lifespan for species 2
  data$half <- log(1/2)/-data$degr #viral half-life
  data$epid <- data$eigen > 1 #invasion potential (i.e. R0 > 1)
  data$prop1 <- data$trans1/data$trans2 #proportion of transmission of species 2 over species 1
  data$prop3 <- data$trans3/data$trans2 #proportion of environmental transmission over species 1
  data$prop_mort <- data$mort1/data$mort2 #relative mortality for species 1 and 2
  data$cap1 <- data$birth1/data$mort1 #carrying capacity for species 1
  data$cap2 <- data$birth2/data$mort2 #carrying capacity for species 2
  data$cap_prop <- data$cap1/data$cap2 #relative carrying capacities for species 1 and 2
  data$tot <- data$cap1 + data$cap2 #total abundance for species 1 and 2
  data$cc <- data$trans1*(data$cap1/data$tot) + data$trans2*(data$cap2/data$tot) #cc defined as transmission of a species multiplied by its relative abundance
  output <- data %>% dplyr::select(trans1, trans2, prop1, prop3, trans3, eigen, prop_mort, mort1, mort2, degr, half, cap1, cap2, cap_prop, tot, cc) %>% distinct()
  return(output)
}

reference <- contour(trans_1_min = 0.0001,trans_1_max = 0.001,trans_3_min = 0.0001,trans_3_max = 0.001,mort1 = 1/45,mort2 = 1/45,degr = 1/2)

composition <- contour(trans_1_min = 0.0001,trans_1_max = 0.001,trans_3_min = 0.0001,trans_3_max = 0.001,mort1 = 1/60,mort2 = 1/30,degr = 1/2)

size <- contour(trans_1_min = 0.0001,trans_1_max = 0.001,trans_3_min = 0.0001,trans_3_max = 0.001,mort1 = c(1/50),mort2 = c(1/50),degr = 1/2)

halflife <- contour(trans_1_min = 0.0001,trans_1_max = 0.001,trans_3_min = 0.0001,trans_3_max = 0.001,mort1 = c(1/40),mort2 = 1/40,degr = c(1/4))

combined <- contour(trans_1_min = 0.0001,trans_1_max = 0.001,trans_3_min = 0.0001,trans_3_max = 0.001,mort1 = c(1/66.6),mort2 = c(1/33.3),degr = c(1/4))

```

community matrix for PCA - primarily used by fig2
```{r}
#select for community variables
community_mat <- data %>% dplyr::select(WetAltID, Month.1, AB2:AB8, AB9, AB20:AB42) 
community_mat$Month.1 <- gsub("Month", "", community_mat$Month.1)
community_mat %<>% mutate(., siteID = paste(WetAltID, Month.1, sep = "_")) %>% distinct() %>% arrange(.,WetAltID) %>% dplyr::select(-WetAltID, -Month.1) %>% dplyr::select(siteID, AB2:AB42)
#rownames
community_mat %<>% column_to_rownames(., var = "siteID")

#select for environmental variables
env <- data %>% dplyr::select(WetAltID, Month.1, MeanAirT, MeanWaterTempPredC, DryingScore, CanopyCover, Area, Perimeter) %>% distinct() %>% arrange(.,WetAltID) 
env$Month.1 <- gsub("Month", "", env$Month.1)
#make siteID rowname
env$siteID <- paste(env$WetAltID, env$Month.1, sep = "_")
env %<>% dplyr::select(-WetAltID, -Month.1)
#remove duplicated rows (siteID is duplicated but env. variables are not... not sure why this is)
env <- env[-c(53, 90),]
env_mat <- env %>% column_to_rownames(., var = "siteID")

#replace NA's with zeros. Probably not the best option but will allow analysis to run for now
community_mat[is.na(community_mat)] <- 0
env_mat[is.na(env_mat)] <- 0

#pca on community matrix and gather scores for first two principal components
pca <- princomp(community_mat, scores = TRUE)
summary(pca)
scores <- as.data.frame(pca$scores)
scores %<>% dplyr::select(Comp.1, Comp.2) %>% rownames_to_column(., var = "siteID")

#plot pca
biplot(pca)


tmp <- data %>% dplyr::select(WetAltID, Month.1, cc, Month, AB2:AB42) %>% 
  dplyr::select(-ABAmb, -ABSal) %>%  mutate(., Size = rowSums(.[5:25])) %>% #get totals for community size
  dplyr::select(-AB2:-AB42) %>%
  mutate(., siteID = paste(WetAltID, Month.1, sep = "_")) %>%
  distinct()
tmp$siteID <- gsub("Month", "", tmp$siteID)

site_scores  <- inner_join(tmp, scores, by = "siteID")

#order months
site_scores$Month <- factor(site_scores$Month, levels = c("Feb", "Mar", "Apr", "May", "Jun", "Jul"))

#rank order components and plot in order
site_scores %<>% mutate(pc1Rank=dense_rank(Comp.1))
```

cc x evenness data - primarily used by fig3
```{r}
#Get species richness from matrix

community_mat <- data %>% dplyr::select(WetAltID, Month.1, AB2:AB8, AB9, AB20:AB42) %>%
  mutate(., siteID = paste(WetAltID, Month.1, sep = "_")) %>% distinct() 

community_mat <- community_mat[order(community_mat$WetAltID, community_mat$Month.1),]

community_mat %<>% arrange(.,WetAltID) %>% dplyr::select(-WetAltID, -Month.1) %>% dplyr::select(siteID, AB2:AB42)

abundances <- community_mat

community_mat %<>% column_to_rownames(., var = "siteID")

presence_mat <- ifelse(community_mat>0, 1, 0)

siteID <- rownames(presence_mat)

richness_mat <- tibble()
for (i in 1:length(siteID)){
  richness_mat[i,1] <- siteID[i]
  richness_mat[i,2] <- sum(presence_mat[i,])
}
richness_mat %<>% rename(siteID = 1, richness = 2)

order <- richness_mat

#Get species richness for each site and community competence values

tmp <- data %>% dplyr::select(WetAltID, Month.1, cc, Prevalence,AB2:AB8, AB9, AB20:AB42) %>% 
  distinct() %>% 
  mutate(., siteID = paste(WetAltID, Month.1, sep = "_"))
tmp %<>% mutate(.,size = rowSums(.[5:25])) %>% select(-c(AB2:AB42))
tmp <- tmp[order(tmp$WetAltID, tmp$Month.1),]
tmp %<>% dplyr::select(-Month.1)

richness_cc <- full_join(tmp, richness_mat, by = "siteID")



#J = H'/ln(S)
#H' = Shannon diversity index
#S = Species Richness

h <- vegan::diversity(community_mat, index = "shannon")
h <- melt(as.matrix(h))
h %<>% rename(siteID = Var1, h = value) %>% dplyr::select(-Var2)

evenness <- richness_cc %>% mutate(lnS = log(richness)) %>% rowwise()

evenness %<>% full_join(h, evenness, by = "siteID")

evenness %<>% mutate(J = h/lnS) %>% rowwise()

#create new df for ordered sites to test lagged richness and evenness on prevalence
lag_evenness <- evenness[-c(4,14,47,90),]
lag_evenness$lag_richness <- c(0)
lag_evenness$lag_J <- c(0)
lag_evenness$lag_cc <- c(0)
lag_evenness$lag_size <- c(0)
for(n in 2:91){
  lag_evenness$lag_richness[n] <- lag_evenness$richness[n-1]
  lag_evenness$lag_J[n] <- lag_evenness$J[n-1]
  lag_evenness$lag_cc[n] <- lag_evenness$cc[n-1]
  lag_evenness$lag_size[n] <- lag_evenness$size[n-1]
}

#remove the first entry for each wetland to remove the carryover from the last wetland
lag_evenness %<>% group_by(WetAltID) %>% filter(duplicated(WetAltID) | n()==1)

#fit two lines to cc_evenness_prev plot
lag_evenness$high <- c(0)
lag_evenness$low <- c(0)
for (i in 1:nrow(lag_evenness)){
  if (lag_evenness$lag_J[i] > 0.6){
    lag_evenness$high[i] <- 1
    lag_evenness$low[i] <- 1
  }
  else if (lag_evenness$lag_cc[i] < 45000){
    lag_evenness$low[i] <- 1
  }
  else if (lag_evenness$lag_cc[i] > 45000){
    lag_evenness$high[i] <- 1
  }
  else {
    lag_evenness$high[i] <- 0
    lag_evenness$low[i] <- 0
  }
}
low_cc <- lag_evenness %>% filter(low==1)
cor.test(x=low_cc$lag_J, y=low_cc$lag_cc,method = "spearman")
high_cc <- lag_evenness %>% filter(high==1)
cor.test(x=high_cc$lag_J, y=high_cc$lag_cc,method = "spearman")
```

data for bar plots - primarily used by fig4
```{r}

#Get species richness from matrix

community_mat <- data %>% dplyr::select(WetAltID, Month.1, AB2:AB8, AB9, AB20:AB42) %>%
  mutate(., siteID = paste(WetAltID, Month.1, sep = "_")) %>% distinct() #select data and make siteID column

community_mat <- community_mat[order(community_mat$WetAltID, community_mat$Month.1),] #order by wetland and month

community_mat %<>% arrange(.,WetAltID) %>% dplyr::select(-WetAltID, -Month.1) %>% dplyr::select(siteID, AB2:AB42)

abundances <- community_mat #make abundances df

community_mat %<>% column_to_rownames(., var = "siteID") #make sitexspecies matrix

presence_mat <- ifelse(community_mat>0, 1, 0) #make pres-abs sitexspecies matrix

siteID <- rownames(presence_mat)

richness_mat <- tibble()
for (i in 1:length(siteID)){
  richness_mat[i,1] <- siteID[i]
  richness_mat[i,2] <- sum(presence_mat[i,])
}
richness_mat %<>% rename(siteID = 1, richness = 2) #make df with siteIDs and corresponding species richness

#Get species richness for each site and community competence values

tmp <- data %>% dplyr::select(WetAltID, Month.1, cc, Prevalence,AB2:AB8, AB9, AB20:AB42) %>% 
    distinct() %>% 
    mutate(., siteID = paste(WetAltID, Month.1, sep = "_"))
tmp %<>% mutate(.,size = rowSums(.[5:25])) %>% select(-c(AB2:AB42))
tmp <- tmp[order(tmp$WetAltID, tmp$Month.1),]
tmp %<>% dplyr::select(-Month.1)

richness_cc <- full_join(richness_mat, tmp, by = "siteID") #make df with siteIDs, richness, and cc



#J = H'/ln(S)
#H' = Shannon diversity index
#S = Species Richness

h <- vegan::diversity(community_mat, index = "shannon") #calculate shannons index for each site-month
h <- melt(as.matrix(h)) #melt into df
h %<>% rename(siteID = Var1, h = value) %>% dplyr::select(-Var2) #get df with shannons index for each site-month

evenness <- richness_cc %>% mutate(lnS = log(richness)) %>% rowwise() 
evenness %<>% full_join(h, evenness, by = "siteID")
evenness %<>% mutate(J = h/lnS) %>% rowwise() #calculate Pielou's J

#test for prevalence-richness relationship

evenness %>% ggplot(.,aes(x=richness, y=Prevalence))+
  geom_smooth(method="lm")
cor.test(evenness$richness,evenness$Prevalence,method="spearman")


#create new df for ordered sites to test lagged richness and evenness on prevalence
lag_evenness <- evenness[-c(4,14,47,90),] #remove site-months that are out of sequence
lag_evenness$lag_richness <- c(0)
lag_evenness$lag_J <- c(0)
lag_evenness$lag_cc <- c(0)
lag_evenness$lag_size <- c(0)
for(n in 2:91){ #lag values by one month
  lag_evenness$lag_richness[n] <- lag_evenness$richness[n-1]
  lag_evenness$lag_J[n] <- lag_evenness$J[n-1]
  lag_evenness$lag_cc[n] <- lag_evenness$cc[n-1]
  lag_evenness$lag_size[n] <- lag_evenness$size[n-1]
}
#remove the first entry for each wetland to remove the carryover from the last wetland
lag_evenness %<>% group_by(WetAltID) %>% filter(duplicated(WetAltID) | n()==1)
#lag_evenness %<>% select(siteID, lag_richness:lag_size)

lag_evenness %>% ggplot(.,aes(x=lag_richness, y=Prevalence))+
  geom_smooth(method="lm")
cor.test(lag_evenness$lag_richness,lag_evenness$Prevalence,method="spearman")



#barplots comparing community composition



evenness %<>% select(-WetAltID)
abundances %<>% left_join(.,evenness, by = "siteID")
lag_evenness %<>% select(siteID, lag_cc, lag_richness, lag_J, lag_size)
abundances %<>% inner_join(.,lag_evenness, by = "siteID")
abundances <- mutate(abundances, ABHigh = (AB9 + AB21 + AB26 + AB42)) 
abundances <- mutate(abundances, ABLow = (AB2 + AB3 + AB4 + AB5 + AB6 + AB8 + AB20 + AB24 + AB27 + AB28 + AB29 + AB31 + AB34 + AB35 + AB38 + AB39 + AB41))
abundances <- mutate(abundances, total = ABHigh + ABLow)
#final df for plots. includes data for abundance, prevalence, cc, diversity measure, lagged values


abundances$siteID <- reorder(abundances$siteID, -abundances$total) #order by total community size
#abundances$siteID <- reorder(abundances$siteID, -abundances$cc) #order by community competence
#abundances$siteID <- reorder(abundances$siteID, -abundances$J) #order by Pielou's J

```

correlations - primarily used by fig5
```{r}
prev_cc <- data %>% dplyr::select(WetAltID, Month.1, cc, Prevalence, Month, AB2:AB42, MeanWaterTempPredC)
prev_cc %<>% dplyr::select(-ABAmb, -ABSal) %>%  mutate(., total = rowSums(.[6:26])) #get totals for community size
prev_cc %<>% dplyr::select(-AB2:-AB42)
prev_cc %<>% distinct()

order <- prev_cc[order(prev_cc$WetAltID, prev_cc$Month.1),]

#this removes months out of sequence
order <- order[-c(4,14,47,90),]

order$lag_cc <- order$cc
order$lag_size <- order$total
order$lag_temp <- order$MeanWaterTempPredC

#create new column that includes previous month's value for cc
for(n in 2:nrow(order)){
  order$lag_cc[n] <- order$cc[n-1]
  order$lag_size[n] <- order$total[n-1]
  order$lag_temp[n] <- order$MeanWaterTempPredC[n-1]
}

#remove the first entry for each wetland to remove the carryover from the last wetland
clean <- order %>% group_by(WetAltID) %>% filter(duplicated(WetAltID) | n()==1)

```

